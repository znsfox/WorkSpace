动态规划可以理解为查表的递归（记忆化）。



## 递归：

在函数的定义中使用函数自身的方法。

递归不是算法，它是和迭代对应的一种编程方法，不过前者隐式地借助了函数调用栈。

一个问题要使用递归必须要有递归终止条件。



练习递归：

可以将迭代写的算法改成递归的形式。



递归中的重复计算：

在递归中可能存在许多重复性的计算，为了消除这种计算，一种简单的方式就是记忆化递归。即一边递归，一边使用“记录表”（比如哈希表或者数组）记录已经计算过的情况。





## 动态规划：

动态规划就是枚举所有可能，不过相比暴力枚举，动态规划不会有重复计算。因此如何保证枚举时不重不漏是关键点之一。



#### 如何解决重复运算：

“查表”，不过区别于递归使用函数调用栈，动态规划通常使用的是dp数组，数组的索引通常是问题规模，值通常是递归函数的返回值。



技巧：

滚动数组 



```
递归是从结果倒推，直到问题的规模缩小到寻常
动态规划是从寻常入手，逐步扩大规模到最优子结构 

递归调用栈枚举状态，而动态规划使用迭代枚举状态

记忆化递归和动态规划没有本质不同，都是根据状态的直接联系逐步推导求解。


动态规划通常性能更好，一方面是递归的栈开销，一方面是滚动数组的技巧。
```



#### 三个要素：

状态转移方程

临界条件

枚举状态



可以看出，用递归解决也是一样的思路

在上面讲解的爬楼梯问题中，如果我们用 f(n) 表示爬 n 级台阶有多少种方法的话，那么：

```
f(1) 与 f(2) 就是【边界】
f(n) = f(n-1) + f(n-2) 就是【状态转移公式】
```



我们用动态规划的形式表示一下：

```
dp[0] 与 dp[1] 就是【边界】
dp[n] = dp[n - 1] + dp[n - 2] 就是【状态转移方程】
```





### 动态规划画表格！！！



#### 难点：

- 枚举所有状态
- 寻找状态转移方程





### 子问题：

子问题和原问题相似，但规模较小 ==> 最优子结构 ==> *f*(*k*) 可以由 f(k-1)*f*(*k*−1) 和 f(k-2)*f*(*k*−2) 求出



### 计算顺序

- 一种是自顶向下，采用备忘录的递归方法，
- 一种是自底向上，采用dp数组的循环方法

在普通的动态规划问题中，大多数情况都不需要用到备忘录方法，一般使用的是自底向上的dp数组 



dp数组也叫子问题数组，因为DP数组中每一个元素都代表一个子问题

